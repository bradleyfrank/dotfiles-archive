#!/bin/bash
# Forked from: Alan K. Stebbens <aks@stebbens.org> [http://github.com/aks]

LAST_EXIT_STATUS="$?"
DEBUG=1
IS_GIT_DIR=1

fgRed="\[\033[0;31m\]"
fgGreen="\[\033[0;32m\]"
fgYellow="\[\033[0;33m\]"
fgBlue="\[\033[0;34m\]"
fgMagenta="\[\033[0;35m\]"
fgTeal="\[\033[0;36m\]"
fgDimWhite="\[\033[2;37m\]"
fgWhite="\[\033[0;37m\]"
ResetColor="\[\033[0;0m\]"

state=""
step=""
total=""
num_staged=0
num_changed=0
num_conflicts=0
num_untracked=0
num_stashed=0
clean=0

ps1_git_prompt=""
ps1_env_prompt=""


__git_prompt_read() {
	local f="$1"
	shift
	test -r "$f" && read "$@" <"$f"
}


__git_prompt_state() {
  if [ -d "${git_dir}/rebase-merge" ]; then
    __git_prompt_read "${git_dir}/rebase-merge/msgnum" step
    __git_prompt_read "${git_dir}/rebase-merge/end" total
    if [ -f "${git_dir}/rebase-merge/interactive" ]; then
      state="|REBASE-i"
    else
      state="|REBASE-m"
    fi
  else
    if [ -d "${git_dir}/rebase-apply" ]; then
      __git_prompt_read "${git_dir}/rebase-apply/next" step
      __git_prompt_read "${git_dir}/rebase-apply/last" total
      if [ -f "${git_dir}/rebase-apply/rebasing" ]; then
        state="|REBASE"
      elif [ -f "${git_dir}/rebase-apply/applying" ]; then
        state="|AM"
      else
        state="|AM/REBASE"
      fi
    elif [ -f "${git_dir}/MERGE_HEAD" ]; then
      state="|MERGING"
    elif [ -f "${git_dir}/CHERRY_PICK_HEAD" ]; then
      state="|CHERRY-PICKING"
    elif [ -f "${git_dir}/REVERT_HEAD" ]; then
      state="|REVERTING"
    elif [ -f "${git_dir}/BISECT_LOG" ]; then
      state="|BISECTING"
    fi
  fi

  #if [ -n "$step" ] && [ -n "$total" ]; then
  #  state="${state} ${step}/${total}"
  #fi
}


__git_prompt_status_counts() {
  while IFS='' read -r line || [[ -n "$line" ]]; do
    status=${line:0:2}
    while [[ -n $status ]]; do
      case "$status" in
        #two fixed character matches, loop finished
        \#\#) branch_line="${line/\.\.\./^}"; break ;;
        \?\?) ((num_untracked++)); break ;;
        U?) ((num_conflicts++)); break;;
        ?U) ((num_conflicts++)); break;;
        DD) ((num_conflicts++)); break;;
        AA) ((num_conflicts++)); break;;
        #two character matches, first loop
        ?M) ((num_changed++)) ;;
        ?D) ((num_changed++)) ;;
        ?\ ) ;;
        #single character matches, second loop
        U) ((num_conflicts++)) ;;
        \ ) ;;
        *) ((num_staged++)) ;;
      esac
      status=${status:0:(${#status}-1)}
    done
  done <<< "$gitstatus"
}


__git_prompt_num_stashed() {
  stash_file="$(git rev-parse --git-dir)/logs/refs/stash"
  if [[ -e "${stash_file}" ]]; then
    while IFS='' read -r wcline || [[ -n "$wcline" ]]; do
      ((num_stashed++))
    done < ${stash_file}
  fi
}


__git_prompt_is_clean() {
  if (( num_changed == 0 && num_staged == 0 && num_untracked == 0 && num_stashed == 0 && num_conflicts == 0)) ; then
    clean=1
  fi
}


__git_prompt_branches() {
  IFS="^" read -ra branch_fields <<< "${branch_line/\#\# }"
  branch="${branch_fields[0]}"
  remote=
  upstream=

  if [[ "$branch" == *"Initial commit on"* ]]; then
    IFS=" " read -ra fields <<< "$branch"
    branch="${fields[3]}"
    remote="_NO_REMOTE_TRACKING_"
  elif [[ "$branch" == *"No commits yet on"* ]]; then
    IFS=" " read -ra fields <<< "$branch"
    branch="${fields[4]}"
    remote="_NO_REMOTE_TRACKING_"
  elif [[ "$branch" == *"no branch"* ]]; then
    tag=$( git describe --tags --exact-match )
    if [[ -n "$tag" ]]; then
      branch="$tag"
    else
      branch="_PREHASH_$( git rev-parse --short HEAD )"
    fi
  else
    if [[ "${#branch_fields[@]}" -eq 1 ]]; then
      remote="_NO_REMOTE_TRACKING_"
    else
      IFS="[,]" read -ra remote_fields <<< "${branch_fields[1]}"
      upstream="${remote_fields[0]}"
      for remote_field in "${remote_fields[@]}"; do
        if [[ "$remote_field" == "ahead "* ]]; then
          num_ahead=${remote_field:6}
          ahead="_AHEAD_${num_ahead}"
        fi
        if [[ "$remote_field" == "behind "* ]] || [[ "$remote_field" == " behind "* ]]; then
          num_behind=${remote_field:7}
          behind="_BEHIND_${num_behind# }"
        fi
      done
      remote="${behind}${ahead}"
    fi
  fi

  if [[ -z "$remote" ]] ; then
    remote='.'
  fi

  if [[ -z "$upstream" ]] ; then
    upstream='^'
  fi
}


if gitstatus=$(LC_ALL=C git status --ignore-submodules --porcelain --branch 2>/dev/null); then
  IS_GIT_DIR=0
fi

if ! git_dir="$(git rev-parse --git-dir 2>/dev/null)"; then
  IS_GIT_DIR=1
fi


if [[ $IS_GIT_DIR -eq 0 ]]; then
  __git_prompt_state
  __git_prompt_status_counts
  __git_prompt_num_stashed
  __git_prompt_is_clean
  __git_prompt_branches

  if [[ $DEBUG -eq 0 ]]; then
    printf "%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" \
      "branch: ${branch}${state}" \
      "remote: $remote" \
      "upstream: $upstream" \
      "staged: $num_staged" \
      "conflicts: $num_conflicts" \
      "changed: $num_changed" \
      "untracked: $num_untracked" \
      "stashed: $num_stashed" \
      "is clean: $clean"
  fi

  _staged=""
  _conflicts=""
  _changed=""
  _untracked=""
  _stashed=""

  _div="${fgDimWhite}|${ResetColor}"

  if [[ $num_staged -gt 0 ]]; then
    _staged="${fgMagenta}⋮${num_staged}${ResetColor}${_div}"
  fi

  if [[ $num_conflicts -gt 0 ]]; then
    _conflicts="${fgRed}✗${num_conflicts}${ResetColor}${_div}"
  fi

  if [[ $num_changed -gt 0 ]]; then
    _changed="${fgYellow}+${num_changed}${ResetColor}${_div}"
  fi

  if [[ $num_untracked -gt 0 ]]; then
    _untracked="${fgWhite}…${num_untracked}${ResetColor}${_div}"
  fi

  if [[ $num_stashed -gt 0 ]]; then
    _stashed="${fgBlue}⚑${num_stashed}${ResetColor}${_div}"
  fi

  _git_branch="${fgGreen}${branch}${state}${ResetColor}"
  _git_status=" ${_conflicts}${_staged}${_changed}${_untracked}${_stashed}"
  if [[ ${#_git_status} -gt 0 ]]; then
    _git_status=$(echo " $_git_status")
  fi
  ps1_git_prompt=" ${fgWhite}on${ResetColor} ${_git_branch}${_git_status}"
fi


if [[ ! -z $CONDA_DEFAULT_ENV ]]; then
  _env_name="${fgTeal}${CONDA_DEFAULT_ENV}${ResetColor}"
  ps1_env_prompt=" ${fgWhite}in${ResetColor} ${_env_name}"
fi


if [[ $LAST_EXIT_STATUS -eq 0 ]]; then
  ps1_prefix="${fgWhite}⋊>${ResetColor}"
else
  ps1_prefix="${fgRed}⋊>${ResetColor}"
fi

_cwd="${fgYellow}\w${ResetColor}"
PS1="${ps1_prefix} ${_cwd}${ps1_git_prompt}${ps1_env_prompt} "
