#!/bin/bash

set -eu

OS=""
OUTPUT=""
PIP="NaN"
DATE=$(date +%Y%m%d%H%M%S)

CONF_DIR="$HOME/.config"
DOTFILES_CONF_DIR="$CONF_DIR/dotfiles"
DOTFILES_ARCHIVE="$DOTFILES_CONF_DIR/archive"

PROFILE_TEMPLATE="$(find -L "$CONF_DIR" -name bash_profile.template | head -1)"
RC_TEMPLATE="$(find -L "$CONF_DIR" -name bashrc.template | head -1)"

PROFILE_TEMP="$(mktemp)"
RC_TEMP="$(mktemp)"

PROFILE="$HOME/.bash_profile"
RC="$HOME/.bashrc"


# =============================================================================
# FUNCTIONS
# =============================================================================

# -----------------------------------------------------------------------------
# Common functions
# -----------------------------------------------------------------------------

skip() {
  return 1
}

convert_template() {
  local bash_template="$1" bash_config="$2"

  IFS=''
  while read -r line || [[ -n "$line" ]]; do
    if echo "$line" | grep -qE '%%'; then
      # get variable - which serves as a function
      func=$(echo "$line" | sed -e 's/^[ ]*//' | cut -d ' ' -f 2)

      # set an empty line to 'skip' so the line isn't printed
      if [[ "$func" == "%%" ]]; then func="skip"; fi

      # find the corresponding function to print content
      if eval "$func"; then
        echo -e "$OUTPUT" >> "$bash_config"
      fi
    else
      echo "$line" >> "$bash_config"
    fi
  done < "$bash_template"
}


# -----------------------------------------------------------------------------
# bash_profile functions
# -----------------------------------------------------------------------------

#
# Mac needs to add ~/Library Python 3.7 to PATH
#
mac_path_anaconda() {
  if [[ "$OS" == "macos" ]] && [[ -d "$HOME/Library/Python/3.7/bin" ]]; then
    OUTPUT="PATH=\"\$HOME/Library/Python/3.7/bin:\$PATH\""
  else
    return 1
  fi
}


#
# Add GNU packages to Mac's PATH
#
mac_path_brewgnu() {
  if [[ "$OS" != "macos" ]]; then return 1; fi

  local tmpout binpath

  while read -r formula; do
    binpath=$(printf 'PATH=\"%s:\$PATH\"' "$formula")
    tmpout=$(printf '%s%s\\n' "$tmpout" "$binpath")
  done <<< "$(find -L "$(brew --prefix)"/opt -type d -name 'gnubin')"

  # removes last two characters (newline)
  OUTPUT="${tmpout%??}"
}


#
# Add GNU packages to Mac's MANPATH
#
mac_manpath_brewgnu() {
  if [[ "$OS" != "macos" ]]; then return 1; fi

  local tmpout manpath

  while read -r formula; do
    manpath=$(printf 'MANPATH=\"\$MANPATH:%s\"' "$formula")
    tmpout=$(printf '%s%s\\n' "$tmpout" "$manpath")
  done <<< "$(find -L "$(brew --prefix)"/opt -type d -name 'gnuman')"

  # removes last two characters (newline)
  OUTPUT="${tmpout%??}"
}


# -----------------------------------------------------------------------------
# bashrc functions
# -----------------------------------------------------------------------------

#
# Various aliases that replace known/built-in commands
#
alias_anaconda() {
  if [[ -f /usr/local/anaconda3/bin/activate ]]; then
    OUTPUT="alias anaconda='source /usr/local/anaconda3/bin/activate root'"
  else
    return 1
  fi
}

alias_ncdu() {
  if type ncdu >/dev/null 2>&1; then
    OUTPUT="alias du='ncdu'"
  else
    return 1
  fi
}

alias_prettyping() {
  if type prettyping >/dev/null 2>&1; then
    OUTPUT="alias ping='prettyping'"
  else
    return 1
  fi
}

alias_pydf() {
  if type pydf >/dev/null 2>&1; then
    OUTPUT="alias df='pydf'"
  else
    return 1
  fi
}

alias_rmate() {
  if type rmate >/dev/null 2>&1; then
    OUTPUT="alias mate='rmate'"
  else
    return 1
  fi
}


#
# Enables thefuck alias if installed
#
eval_thefuck() {
  if type thefuck >/dev/null 2>&1; then
    OUTPUT="eval \$(thefuck --alias)"
  else
    return 1
  fi
}


#
# Use keychain if installed with specific per-system options
#
eval_keychain() {
  if ! type keychain >/dev/null 2>&1; then return 1; fi

  local inherit=""
  local flags="--eval --ignore-missing --quiet"
  local keys="id_esai id_home id_develop id_rsa id_ed25519"

  if [[ "$OS" == "macos" ]]; then
    inherit="--inherit any "
  fi

  OUTPUT="eval \"\$(keychain $flags $inherit$keys)\""
}


#
# Enable MacOS terminal options
#
export_termopts() {
  if [[ "$OS" != "macos" ]]; then return 1; fi

  OUTPUT=$(printf '%s\n' \
    "export EDITOR=\"/usr/local/bin/mate -w\""
  )
}


#
# Source RVM scripts if present
#
source_rvm() {
  if [[ -x "$HOME"/.rvm/scripts/rvm ]]; then
    OUTPUT=". \"$HOME\"/.rvm/scripts/rvm"
  else
    return 1
  fi
}


#
# Sets PS1 to use Powerline (usually reserved for local hosts)
#
powerline_ps1() {
  local sitepkgs

  # Skip if Pip not found on system
  if [[ "$PIP" == "NaN" ]]; then return 1; fi

  sitepkgs=$("$PIP" show powerline-status | grep 'Location' | cut -d ' ' -f 2)

  OUTPUT="$(printf '%s\n' \
    'powerline-daemon -q' \
    'POWERLINE_BASH_CONTINUATION=1' \
    'POWERLINE_BASH_SELECT=1' \
    '. '"${sitepkgs}"'/powerline/bindings/bash/powerline.sh'
  )"
}


# =============================================================================
# Main Exec
# =============================================================================

#
# Determine OS
#
case "$(uname -s)" in
  Darwin) OS="macos" ;;
  Linux)
    if [[ -f /etc/fedora-release ]]; then
      OS="fedora"
    elif [[ -f /etc/centos-release ]] || [[ -f /etc/redhat-release ]]; then
      OS="redhat"
    else
      echo "OS not supported"
      exit 1
    fi
    ;;
  *)
    echo "Linux detection failed"
    exit 1
    ;;
esac


#
# Find Pip executable
#
if type pip3 >/dev/null 2>&1; then
  PIP="pip3"
elif type pip >/dev/null 2>&1; then
  PIP="pip"
fi


#
# Parse templates
#
convert_template "$PROFILE_TEMPLATE" "$PROFILE_TEMP"
convert_template "$RC_TEMPLATE" "$RC_TEMP"


#
# Backup existing profiles
#
if [[ ! -d "$DOTFILES_ARCHIVE" ]];
  then mkdir -p "$DOTFILES_ARCHIVE"
fi

touch "$PROFILE" "$RC" # Ensure files exist or 'mv' will fail
mv "$PROFILE" "$DOTFILES_ARCHIVE"/bash_profile."$DATE"
mv "$RC" "$DOTFILES_ARCHIVE"/bashrc."$DATE"


#
# Move new profiles into place
#
command cp "$PROFILE_TEMP" "$PROFILE"
command cp "$RC_TEMP" "$RC"
chown "$USER" "$PROFILE" "$RC"
chmod 644 "$PROFILE" "$RC"
