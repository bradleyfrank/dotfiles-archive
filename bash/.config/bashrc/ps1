#!/usr/bin/env bash

#
# Instructions for use:
#
# (1) Add to ~/.bashrc ...
# . /path/to/this/file/ps1
# export PROMPT_COMMAND=build_ps1
#
# (2) Use a powerline font for the terminal
# https://github.com/powerline/fonts
#
# (3) Current color selections adapted for Solarized Light
# https://ethanschoonover.com/solarized/
#

# =============================================================================
# USER SETTINGS
# -----------------------------------------------------------------------------

# always show hostname (1)
# only show hostname in SSH sessions w/o tmux (0)
show_hostname=0

# customize date (see `man date` for codes)
date_format="%H:%M:%S"

# always show username (1)
# only show root username (0)
show_username=0

# =============================================================================
# SCRIPT SETTINGS
# -----------------------------------------------------------------------------

_true=0
_false=1

# =============================================================================
# ANSI COLOR DEFINITIONS
# -----------------------------------------------------------------------------

mkBold="\[\e[1m\]"
ResetColor="\[\e[0;0m\]"

# https://jonasjacek.github.io/colors/

bg_LightSeaGreen="\[\e[48;5;37m\]"
bg_DarkRed="\[\e[48;5;52m\]"
bg_SlateBlue3="\[\e[48;5;61m\]"
bg_SteelBlue1="\[\e[48;5;75m\]"
bg_DeepPink4="\[\e[48;5;125m\]"
bg_DarkOrange3="\[\e[48;5;166m\]"
bg_Grey35="\[\e[48;5;240m\]"
bg_Grey54="\[\e[48;5;245m\]"

fg_Lime="\[\e[38;5;10m\]"
fg_White="\[\e[38;5;15m\]"
fg_LightSeaGreen="\[\e[38;5;37m\]"
fg_SlateBlue3="\[\e[38;5;61m\]"
fg_SteelBlue1="\[\e[38;5;75m\]"
fg_DeepPink4="\[\e[38;5;125m\]"
fg_DarkOrange3="\[\e[38;5;166m\]"
fg_Red1="\[\e[38;5;196m\]"
fg_DarkOrange="\[\e[38;5;208m\]"
fg_Orange1="\[\e[38;5;214m\]"
fg_Orchid1="\[\e[38;5;213m\]"
fg_Gold1="\[\e[38;5;220m\]"
fg_Grey35="\[\e[38;5;240m\]"
fg_Grey54="\[\e[38;5;245m\]"

# =============================================================================
# SEGMENT COLORS
# -----------------------------------------------------------------------------

# Hostname segment colors
c_hostname_bg=$bg_SlateBlue3
c_hostname_fg=$fg_White
c_hostname_div_fg=$fg_SlateBlue3

# Date segment colors
c_date_bg=$bg_SteelBlue1
c_date_fg=$fg_White
c_date_div_fg=$fg_SteelBlue1

# User segment colors
c_user_bg=$bg_DarkOrange3
c_user_fg=$fg_White
c_user_div_fg=$fg_DarkOrange3
c_root_bg=$bg_DeepPink4
c_root_fg=$fg_White
c_root_div_fg=$fg_DeepPink4

# Working directory colors
c_cwd_bg=$bg_Grey54
c_cwd_fg=$fg_White
c_cwd_div_fg=$fg_Grey54

# Git segment colors
c_git_bg=$bg_Grey35
c_gitDirty_fg=$fg_Orange1
c_gitClean_fg=$fg_Lime
c_git_div_fg=$fg_Grey35

# Anaconda segment colors
c_venv_bg=$bg_LightSeaGreen
c_venv_fg=$fg_White
c_venv_div_fg=$fg_LightSeaGreen

# Suffix segment colors
c_prompt_bg=""
c_error_bg=$bg_DarkRed
c_error_fg=$fg_White

# Git glyph colors
c_gitPull=$fg_SteelBlue1
c_gitPush=$fg_LightSeaGreen
c_gitStaged=$fg_White
c_gitConflict=$fg_Red1
c_gitChanged=$fg_Gold1
c_gitUntracked=$fg_DarkOrange
c_gitStashed=$fg_Orchid1

# =============================================================================
# SEGMENT GLYPHS
# -----------------------------------------------------------------------------

# https://unicode-table.com/en/

g_div=$'\uE0B0'          # solid triangle; requires powerline font
#g_thinDiv=$'\uE0B1'      # thin arrow
g_prompt="${g_div} "
g_exitPrompt="${g_div} "

g_gitBranch=$'\uE0A0'    # branch symbol; alternatives: 2325, 2387
g_gitPull=$'\u2193'      # down arrow
g_gitPush=$'\u2191'      # up arrow
g_gitStaged=$'\u2713'    # check mark
g_gitConflict=$'\u2718'  # ballot cross mark
g_gitChanged=$'\u002A'   # asterisk
g_gitUntracked=$'\u2026' # ellipsis
g_gitStashed=$'\u2691'   # flag

# =============================================================================
# HELPER FUNCTIONS
# -----------------------------------------------------------------------------

_build_div_segment() {
  local c_fg=$previous_bg c_bg=$1

  if [[ $prior_segment -eq $_true ]]; then
    echo "${c_bg}${c_fg}${g_exitPrompt}${ResetColor}"
  else
    echo "${c_bg} "
  fi
}

# =============================================================================
# FUNCTIONS
# -----------------------------------------------------------------------------

build_cwd() {
  local div working_dir pathdirs numdirs shortpwd=""

  div="${c_cwd_bg}${previous_bg}${g_div}${ResetColor}"

  # replace $HOME with tilde; replace slashes with newlines
  working_dir="$(echo "$PWD" | sed "s|^${HOME}|~|" | sed "s|/|\n|g")"
  # split pwd on newlines into an array
  #     (can't use the -d option; requires Bash > 4.4)
  readarray -t pathdirs <<< "$working_dir"
  # count array size to get number of directories
  numdirs="${#pathdirs[@]}"
  # decrement array size to avoid parsing cwd (which is used later)
  ((numdirs--))

  # iterate through directories to get the first letter of each directory name
  if [[ "$numdirs" -gt 0 ]]; then
    for ((i=0;i<"${numdirs}";i++)); do
      shortpwd="${shortpwd}${pathdirs[$i]:0:1}/"
    done
  fi

  # add the cwd back in so it's shown with a full name
  shortpwd="${shortpwd}${mkBold}${pathdirs[$numdirs]}"
  current_dir="${div}${c_cwd_bg}${c_cwd_fg} ${shortpwd} ${ResetColor}"

  previous_bg=$c_cwd_div_fg
  prior_segment=$_true
}


build_date() {
  local div datestamp

  div="$(_build_div_segment "$c_date_bg")"
  datestamp="$(date +"${date_format}")"
  date="${div}${c_date_bg}${c_date_fg}${datestamp} ${ResetColor}"

  previous_bg=$c_date_div_fg
  prior_segment=$_true
}


build_exitstatus() {
  local div status

  exit_status=""

  if [[ $LAST_EXIT_STATUS -ne 0 ]]; then
    div="$(_build_div_segment "$c_error_bg")"
    status="${c_error_bg}${c_error_fg}${LAST_EXIT_STATUS}"
    exit_status="${div}${status} ${ResetColor}"
  fi
}


build_git() {
  local div

  ps1_git_prompt=""

  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    if build_git_prompt; then
      div="$(_build_div_segment "$c_git_bg")"
      previous_bg=$c_git_div_fg
      prior_segment=$_true
    fi
  fi

  ps1_git_prompt="${div}${ps1_git_prompt}"
}


build_git_prompt() {
  local branch="" origin ab_status ahead=0 behind=0 clean=0
  local conflicts=0 staged=0 changed=0 untracked=0 stashed=0
  local git_ahead="" git_behind="" git_remote="" git_changes=""
  local _conflicts="" _staged="" _changed="" _untracked="" _stashed=""
  local prefix metadata

  if git_dir="$(git rev-parse --git-dir 2>/dev/null)"; then
    # The .git config directory does not have any metadata, so exit
    if [[ "$git_dir" == "." ]]; then
      return 1
    fi
  else
    return 1
  fi

  # retrieve Git status and metadata
  branch="$(git symbolic-ref --short HEAD 2>/dev/null)"
  origin="$(git rev-parse --abbrev-ref @\{upstream\} 2>/dev/null)"

  if [[ -n $branch ]]; then
    changed="$(git diff --name-only | wc -l)"
    staged="$(git diff --staged --name-only | wc -l)"
    untracked="$(git ls-files . --exclude-standard --others | wc -l)"
    stashed="$(git stash list | wc -l)"
    conflicts="$(git diff --name-status --diff-filter=U | wc -l)"
  elif [[ -d "$(git rev-parse --git-path rebase-merge)" ]] || \
       [[ -d "$(git rev-parse --git-path rebase-apply)" ]]; then
    branch="REBASE"
    clean=1
  fi

  # count commits ahead and behind of upstream
  if [[ -n $origin ]]; then
      ab_status="$(git rev-list --count --left-right "${origin}...HEAD" 2>/dev/null)"
      behind="${ab_status%	*}"
      ahead="${ab_status#*	}"
  fi

  if [[ "$staged" -ne 0 ]] || \
     [[ "$changed" -ne 0 ]] || \
     [[ "$untracked" -ne 0 ]] || \
     [[ "$stashed" -ne 0 ]] || \
     [[ "$conflicts" -ne 0 ]]; then
    clean=1
  fi

  if [[ "$behind" -gt 0 ]]; then
    git_behind=" ${c_gitPull}${g_gitPull}${behind}"
    clean=1
  fi

  if [[ "$ahead" -gt 0 ]]; then
    git_ahead=" ${c_gitPush}${g_gitPush}${ahead}"
    clean=1
  fi

  git_remote="${git_behind}${git_ahead}"

  # set the various repo indictors for any of the "dirty" statuses
  if [[ "$clean" -eq 1 ]]; then
    if [[ $staged -gt 0 ]]; then
      _staged=" ${c_gitStaged}${g_gitStaged}${staged}"
    fi

    if [[ $conflicts -gt 0 ]]; then
      _conflicts=" ${c_gitConflict}${g_gitConflict}${conflicts}"
    fi

    if [[ $changed -gt 0 ]]; then
      _changed=" ${c_gitChanged}${g_gitChanged}${changed}"
    fi

    if [[ $untracked -gt 0 ]]; then
      _untracked=" ${c_gitUntracked}${g_gitUntracked}${untracked}"
    fi

    if [[ $stashed -gt 0 ]]; then
      _stashed=" ${c_gitStashed}${g_gitStashed}${stashed}"
    fi

    # combine all the changes into one string
    git_changes="${_staged}${_conflicts}${_changed}${_untracked}${_stashed}"
    git_changes="${c_git_bg}${git_changes}${ResetColor}"

    # branch is dirty, color it yellow
    prefix="${g_gitBranch} ${branch}"
    prefix="${c_git_bg}${c_gitDirty_fg}${prefix}${ResetColor}"
  else
    # branch is clean, color is green
    prefix="${c_git_bg}${c_gitClean_fg}${g_gitBranch} ${branch}${ResetColor}"
  fi

  # combine remote info with local changes
  metadata="${git_remote}${git_changes}${c_git_bg} ${ResetColor}"

  # build final git prompt
  ps1_git_prompt="${prefix}${c_git_bg}${metadata}"
}


build_hostname() {
  hostname=""

  if [[ ( -n "$SSH_CONNECTION" && -z "$TMUX" ) ]] || \
     [[ "$show_hostname" -eq 1 ]]; then
    div="$(_build_div_segment "$c_hostname_bg")"
    hostname="${div}${c_hostname_bg}${c_hostname_fg}\\h ${ResetColor}"

    previous_bg=$c_hostname_div_fg
    prior_segment=$_true
  fi
}


build_user() {
  local div user
  local c_user c_previous_bg

  user=$(id -un)
  username=""

  if [[ "$user" == "root" ]]; then
    div="$(_build_div_segment "$c_root_bg")"
    c_user="${c_root_bg}${c_root_fg}"
    c_previous_bg=$c_root_div_fg
  else
    div="$(_build_div_segment "$c_user_bg")"
    c_user="${c_user_bg}${c_user_fg}"
    c_previous_bg=$c_user_div_fg
  fi

  if [[ ( "$user" == "root" || $show_username -eq 1 ) ]]; then
    username="${div}${c_user}${user} ${ResetColor}"
    previous_bg=$c_previous_bg
    prior_segment=$_true
  fi
}


build_venv() {
  local div venv

  ps1_env_prompt=""

  if [[ -n $CONDA_DEFAULT_ENV ]]; then
    div="$(_build_div_segment "$c_venv_bg")"
    venv="${c_venv_bg}${c_venv_fg}${CONDA_DEFAULT_ENV} ${ResetColor}"
    ps1_env_prompt="${div}${venv}"

    previous_bg=$c_venv_div_fg
    prior_segment=$_true
  fi
}


# =============================================================================
# MAIN
# -----------------------------------------------------------------------------

build_ps1() {
  # Capture the exit status from the last command
  LAST_EXIT_STATUS="$?"

  # Set initial segment status
  prior_segment=$_false

  # Save previous background color for dividers
  previous_bg=""

  build_hostname
  build_date
  build_user
  build_cwd
  build_git
  build_venv
  build_exitstatus

  _system="${hostname}${date}"
  _environ="${username}${current_dir}${ps1_git_prompt}${ps1_env_prompt}"
  _shell="${exit_status}"
  _suffix="${c_prompt_bg}${previous_bg}${g_prompt}${ResetColor}"

  export PS1="${_system}${_environ}${_shell}${_suffix}"
}

export -f build_ps1
